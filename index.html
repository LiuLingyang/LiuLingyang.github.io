<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="知识即性感">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="知识即性感">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知识即性感">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title> 知识即性感 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">知识即性感</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/2020/一文读懂 css js 阻塞问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/04/24/2020/一文读懂 css js 阻塞问题/" itemprop="url">
                  一文读懂 css js 阻塞问题
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-24T00:00:00+08:00">
                2020-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/24/2020/一文读懂 css js 阻塞问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2020/04/24/2020/一文读懂 css js 阻塞问题/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#前言<br>先抛出几个问题：</p>
<ul>
<li>css 加载会不会阻塞 js 的加载？（不会）</li>
<li>css 加载会不会阻塞 js 的执行？（会）</li>
<li>css 加载会不会阻塞 DOM 的解析？（不会）</li>
<li>css 加载会不会阻塞 DOM 的渲染？（会）</li>
<li>js 加载会不会阻塞 DOM 的解析？（会）</li>
<li>js 加载会不会阻塞 DOM 的渲染？（会）</li>
<li>js 执行会不会阻塞 DOM 的解析？（会）</li>
<li>js 执行会不会阻塞 DOM 的渲染？（会）</li>
</ul>
<p>可以看出 js 是全阻塞的，这也是为什么 js 要放尾部的原因。<br>至于 css 放头部则是为了避免页面一开始样式，而后出现样式导致页面闪动情况，这样用户体验就比较差了。</p>
<p>#浏览器的主要进程和职责<br><img src="https://upload-images.jianshu.io/upload_images/13276697-efa7667456530d8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>关于 css，js 的阻塞问题，都跟浏览器的渲染进程有关。而渲染进程又是多线程的。理清各个线程的职责及相互之间的合作关系，就能窥探其原理。</p>
<ul>
<li>JS 引擎线程（单线程）：负责解析 Javascript 脚本，运行代码</li>
<li>GUI 渲染线程：负责渲染浏览器界面，解析 HTML，CSS，构建 DOM Tree，Style Tree 和 Render Tree，布局和绘制等<blockquote>
<p>注意：GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，所以当 JS 加载和执行时，会阻塞住 DOM 的解析和渲染，导致白屏时间很长</p>
</blockquote>
</li>
</ul>
<p>#浏览器渲染流程<br><img src="https://upload-images.jianshu.io/upload_images/13276697-fd05e089969cdbf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>1.解析 HTML 生成 DOM Tree 2.解析 CSS 生成 Style Tree 3.将 DOM Tree 与 Style Tree 合并在一起生成 Render Tree 4.遍历 Render Tree 开始布局，计算每个节点的位置大小信息（Layout） 5.绘制 Render Tree，绘制页面的像素信息（Painting），显示到屏幕上（Display）</p>
<blockquote>
<p>DOM Tree 和 Style Tree 是并行构建的，所以 CSS 加载不会阻塞 DOM 的解析</p>
</blockquote>
<blockquote>
<p>由于 Render Tree 是依赖于 DOM Tree 和 Style Tree 的，因此，css 加载会阻塞 Dom 的渲染</p>
</blockquote>
<blockquote>
<p>GUI 渲染线程与 JS 引擎线程是互斥的，加载解析 css 时，JS 引擎会被挂起，所以 css 会阻塞 js 的执行</p>
</blockquote>
<p>#回流和重绘</p>
<blockquote>
<p>回流必将引起重绘，重绘不一定会引起回流</p>
</blockquote>
<p>回流(Reflow)：当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时,浏览器重新渲染部分或全部文档的过程称为回流<br>重绘(Repaint)：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等）,浏览器会将新样式赋予给元素并重新绘制它,这个过程称为重绘</p>
<blockquote>
<p>回流比重绘的代价要更高</p>
</blockquote>
<p>#资源加载优先级<br>想要提升页面的加载速度，除了关注 css，js 阻塞的问题外，了解资源加载的优先级同样重要。<br>我们知道资源加载本身不存在互相阻塞的问题，但浏览器依然会按照资源默认的优先级确定加载顺序：<br>1.html 、 css 、 font 这三种类型的资源优先级最高 2.然后 script 、 xhr 请求 3.接着是图片、语音、视频</p>
<p>然而，有些资源我们知道很重要，想优先加载；有些资源无关紧要，想延后加载，那么如何手动控制浏览器加载优先级呢？<br>主要有 4 种指令：</p>
<ul>
<li>preload 预加载（提升优先级）：通知浏览器接下来马上就会用到的资源，并尽快开始加载资源</li>
<li>prefetch 预获取（最低优先级）：通知浏览器这是稍后可能需要用到的东西，可以延迟加载（在带宽空闲(idle)时再加载）</li>
<li>asnyc 异步获取（降低优先级）：资源可以异步加载，加载完即可执行（乱序执行）</li>
<li>defer 异步获取（降低优先级）：资源可以异步加载，但需要按照资源加载顺序执行（按序执行）</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/2019/React 同构实践：服务端请求带 cookies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/06/13/2019/React 同构实践：服务端请求带 cookies/" itemprop="url">
                  React 同构实践：服务端请求带 cookies
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-13T00:00:00+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/13/2019/React 同构实践：服务端请求带 cookies/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2019/06/13/2019/React 同构实践：服务端请求带 cookies/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间搭完 React 同构框架后，自以为很完美，还自我陶醉了好几天。结果，在接公司单点登录系统的时候立马现了原形。<br>公司的单点登录是用 cookie 实现的，传统的 spa 系统 cookie 由浏览器自动携带，不存在任何问题。<br>而 ssr ，是在服务器请求的接口，默认情况肯定带不了浏览器的 cookie，然而一些登录后的页面数据又必须要 cookie，这可怎么办？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将 cookies 作为参数注入到组件的 loadData 方法，然后用传参数的方法把 cookies 传给 api。</p>
<h2 id="1-cookie-parser-中间件解析-cookies"><a href="#1-cookie-parser-中间件解析-cookies" class="headerlink" title="1. cookie-parser 中间件解析 cookies"></a>1. cookie-parser 中间件解析 cookies</h2><p>在项目启动文件中（server/index.js）引入 cookie-parser 中间件解析 cookies<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 cookie</span></span><br><span class="line">app.use(cookieParser());</span><br></pre></td></tr></table></figure></p>
<h2 id="2-将-cookies-作为参数传给-loadData-方法"><a href="#2-将-cookies-作为参数传给-loadData-方法" class="headerlink" title="2. 将 cookies 作为参数传给 loadData 方法"></a>2. 将 cookies 作为参数传给 loadData 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matchs = matchRoutes(router, request.path);</span><br><span class="line">promises = matchs.map(<span class="function">(<span class="params">&#123; route, match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loadData = route.loadData;</span><br><span class="line">  <span class="comment">// 携带上cookie，合并到 params 中，axios 中处理</span></span><br><span class="line">  <span class="keyword">return</span> loadData ? loadData(store, <span class="built_in">Object</span>.assign(match.params, request.query, &#123; <span class="attr">cookies</span>: request.cookies &#125;)) : <span class="built_in">Promise</span>.resolve(<span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="3-loadData-传给异步-action"><a href="#3-loadData-传给异步-action" class="headerlink" title="3. loadData 传给异步 action"></a>3. loadData 传给异步 action</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadData(store, params) &#123;</span><br><span class="line">  <span class="keyword">return</span> store.dispatch(fetchTopList(params));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-发起请求"><a href="#4-发起请求" class="headerlink" title="4. 发起请求"></a>4. 发起请求</h2><p>在异步 action 处理函数中带着 cookies 发起异步请求<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchTopList</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getTopList(data).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(setTopList(result.topList));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-axios-封装"><a href="#5-axios-封装" class="headerlink" title="5. axios 封装"></a>5. axios 封装</h2><p>在 axios 中解析出 params 携带的 cookies，并加到 axios 的 headers 里<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parseCookie = <span class="function"><span class="params">cookies</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cookie = <span class="string">''</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(cookies).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    cookie+= item + <span class="string">'='</span> + cookies[item] + <span class="string">'; '</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> cookie;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request(method) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">url, data = &#123;&#125;, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 处理 cookie</span></span><br><span class="line">      <span class="keyword">let</span> cookies;</span><br><span class="line">      <span class="keyword">if</span> (data.cookies) &#123;</span><br><span class="line">        cookies = data.cookies;</span><br><span class="line">        <span class="keyword">delete</span> data.cookies;</span><br><span class="line">        opts = <span class="built_in">Object</span>.assign(opts, &#123;</span><br><span class="line">          headers: &#123;</span><br><span class="line">            Cookie: parseCookie(cookies)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> axiosCache[method](url, &#123;</span><br><span class="line">        ...opts,</span><br><span class="line">        params: data</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此，就完成了服务端请求携带 cookie 的问题，但总觉得实现上有点麻烦，不知道是否有更好的办法？<br>希望大神能不吝指教…</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/2019/React 同构实践：结合 Redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/25/2019/React 同构实践：结合 Redux/" itemprop="url">
                  React 同构实践：结合 Redux
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T00:00:00+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/25/2019/React 同构实践：结合 Redux/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2019/05/25/2019/React 同构实践：结合 Redux/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章中，我们介绍了 React 同构的基本原理，但没有涉及数据获取方面。本章我们将结合 Redux 来讲解同构应用中服务端如何异步获取数据。<br>如果你对 Redux 还不够熟悉，请先移步 <a href="http://cn.redux.js.org/" target="_blank" rel="noopener">http://cn.redux.js.org/</a></p>
<h1 id="数据预取"><a href="#数据预取" class="headerlink" title="数据预取"></a>数据预取</h1><p>客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程：</p>
<ul>
<li>创建 Store</li>
<li>根据路由显示组件</li>
<li>派发 Action 获取数据</li>
<li>更新 Store 中的数据</li>
<li>组件 Rerender</li>
</ul>
<p>而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子：</p>
<ul>
<li>创建 Store</li>
<li>匹配请求路由</li>
<li>获取数据</li>
<li>结合数据和组件生成 HTML</li>
</ul>
<p>下面我们分析下服务器端渲染这部分的流程。</p>
<h2 id="创建-Store"><a href="#创建-Store" class="headerlink" title="创建 Store"></a>创建 Store</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (initialState) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    initialState,</span><br><span class="line">    compose(</span><br><span class="line">      applyMiddleware(thunkMiddleware),</span><br><span class="line">      (process.env.NODE_ENV !== <span class="string">'server'</span> &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()) || compose</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是服务端每次 renderToString 都需要创建一个全新的空 Store。</p>
<h2 id="匹配请求路由"><a href="#匹配请求路由" class="headerlink" title="匹配请求路由"></a>匹配请求路由</h2><p>服务端在正式渲染前，如果某些内容是通过异步接口请求获取的，那么就需要在 renderToString 前加载数据，但一般不同的路由都会对应不同的异步请求，所以这里我们需要添加路由匹配的逻辑。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; matchRoutes &#125; = <span class="built_in">require</span>(<span class="string">'react-router-config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配路由</span></span><br><span class="line"><span class="keyword">let</span> matchs = matchRoutes(router, request.path);</span><br><span class="line">promises = matchs.map(<span class="function">(<span class="params">&#123; route, match &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loadData = route.loadData;</span><br><span class="line">  <span class="comment">// match.params获取匹配的路由参数</span></span><br><span class="line">  <span class="keyword">return</span> loadData ? loadData(store, <span class="built_in">Object</span>.assign(match.params, request.query)) : <span class="built_in">Promise</span>.resolve(<span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>这里请求数据需要使用<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.redux.org.cn%2Fdocs%2Fadvanced%2FAsyncActions.html" target="_blank" rel="noopener">异步 Action</a>，使用 redux-thunk 中间件就可以dispatch函数了。<br>而请求数据一般两种做法，第一种直接挂在了路由上，另一种做法是把请求数据的方法放到对应的组件上定义成静态方法。<br>但这里我用了 loadable 动态加载组件后，定义在组件上的静态方法在服务端就取不到，所以只能采用第一种做法（不知道大家有没有遇到这个问题？）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/top-list'</span>,</span><br><span class="line">    component: loadable(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../containers/TopList'</span>)),</span><br><span class="line">    exact: <span class="literal">true</span>,</span><br><span class="line">    loadData(store) &#123;</span><br><span class="line">      <span class="keyword">return</span> store.dispatch(fatchTopList());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="返回-HTML"><a href="#返回-HTML" class="headerlink" title="返回 HTML"></a>返回 HTML</h2><p>获取数据，更新 store 后，可以用 renderToString 生成 html 了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve所有loadData</span></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步数据请求全部完成后进行render</span></span><br><span class="line">  render()；</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure></p>
<p>这里的 render 方法核心就是 renderToString，因为还有一些其他逻辑，所以封装了一层。</p>
<h1 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h1><p>客户端渲染出来的 html 内容要和服务端返回的 html 内容一致，这就需要保证客户端的数据和服务端的数据是一致的。也就是说服务端获取数据生成 store 后，需要同步到客户端。<br>服务端调用 store.getState()，获取到 state 后，通过 window.<strong>INITIAL_STATE</strong> 保存在客户端。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.__INITIAL_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(store.getStat())&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="客户端获取数据"><a href="#客户端获取数据" class="headerlink" title="客户端获取数据"></a>客户端获取数据</h1><p>服务端将数据存到 window.<strong>INITIAL_STATE</strong> 后，客户端需要在 createStore 的时候获取初始化的 state。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务端初始化的state，创建store</span></span><br><span class="line"><span class="keyword">const</span> initialState = <span class="built_in">window</span>.__INITIAL_STATE__;</span><br><span class="line"><span class="keyword">const</span> store = createStore(initialState);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Component /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章主要讲解结合 Redux 情况下的 React 同构应用，所涉及的知识点还是比较多的，单单一篇文章也很难涉及全部的知识点，实际开发过程中更是容易出现千奇八怪的问题。实践出真知，还是要亲自写一下才能深入了解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/23/2019/React 同构实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/23/2019/React 同构实践/" itemprop="url">
                  React 同构实践
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-23T00:00:00+08:00">
                2019-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/23/2019/React 同构实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2019/05/23/2019/React 同构实践/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前单页面应用（SPA）很是流行，同时也带了一些问题，如SEO不友好，首屏加载慢等，为了解决上述问题，所谓的服务端渲染就粉墨登场了。<br>React 作为一个 SPA 应用开发框架同时也支持服务端渲染，本文将详细介绍如何搭建一个 React 服务端渲染的项目。<br>如果你倾向于开箱即用的体验，可以尝试更高层次的解决方案 <a href="https://nextjs.org/" target="_blank" rel="noopener">Next.js</a>。</p>
<p>在你阅读之前，你需要具备以下技术能力：</p>
<blockquote>
<ul>
<li>React 全家桶</li>
<li>Webpack</li>
<li>ES6</li>
<li>Promise</li>
<li>Express</li>
</ul>
</blockquote>
<h1 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h1><p>这里我们把”服务端渲染“一词替换成”同构“。其实，这两个词的背景和所表达的意义大体相同，但又有一定差别：服务端渲染主要侧重架构层面的设计，而同构更侧重代码复用。同构的核心是“同一套代码”，这是脱离于两端角度的另一个维度。</p>
<p>随着 Node.js 的异军突起，前后端开发有了归一化编程语言的基础土壤，同构的概念也因此得以更广泛的传播，React 率先引领了这种潮流。同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互。</p>
<h2 id="同构的优势"><a href="#同构的优势" class="headerlink" title="同构的优势"></a>同构的优势</h2><ul>
<li>更好的性能</li>
<li>SEO 优化</li>
<li>同一套代码，可维护性更强</li>
<li>更好的用户体验</li>
</ul>
<h2 id="同构的劣势"><a href="#同构的劣势" class="headerlink" title="同构的劣势"></a>同构的劣势</h2><ul>
<li>服务端处理逻辑增多，增加了复杂性</li>
<li>增加了服务端 TTFB（Time To First Byte）时间，降低了服务端返回的速度</li>
</ul>
<h1 id="认识-renderToString-和-hydrate"><a href="#认识-renderToString-和-hydrate" class="headerlink" title="认识 renderToString 和 hydrate"></a>认识 renderToString 和 hydrate</h1><p>为了实现服务端渲染，打造同构应用，React 也实现了相应的 API。依赖 React 提供的 ReactDOMServer 对象可以实现服务端渲染。ReactDOMServer 对象主要提供 renderToString 方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactDOMServer = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>);</span><br><span class="line">ReactDOMServer.renderToString(element);</span><br></pre></td></tr></table></figure></p>
<p>该方法接受一个 React element，并将此 element 转化为 HTML 字符串，通过浏览器返回。因此，在服务端将页面拼接字符串插入 HTML 文档中并返回给浏览器，完成初步服务端渲染的目的。<br>为了客户端在渲染组件时，最大限度地保留在服务端使用 renderToString 生成的内容结构，ReactDom 相应的在客户端提供了一个新的 API：hydrate。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line">ReactDOM.hydrate(App, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>));</span><br></pre></td></tr></table></figure></p>
<p>前菜已经上齐了，下一节开始上正餐。</p>
<h1 id="客户端路由与服务器端路由的差异"><a href="#客户端路由与服务器端路由的差异" class="headerlink" title="客户端路由与服务器端路由的差异"></a>客户端路由与服务器端路由的差异</h1><p>实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码。</p>
<h2 id="客户端路由（entry-client-js）："><a href="#客户端路由（entry-client-js）：" class="headerlink" title="客户端路由（entry-client.js）："></a>客户端路由（entry-client.js）：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = <span class="function">(<span class="params">Component</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取服务端初始化的state，创建store</span></span><br><span class="line">  <span class="keyword">const</span> initialState = <span class="built_in">window</span>.__INITIAL_STATE__;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;BrowserRouter&gt;</span><br><span class="line">          &lt;Component /&gt;</span><br><span class="line">        &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">ReactDOM.hydrate(createApp(Root), document.getElementById('app'));</span></span><br></pre></td></tr></table></figure>
<p>客户端路由代码非常简单，大家一定很熟悉，BrowserRouter 会自动从浏览器地址中，匹配对应的路由组件显示出来。</p>
<h2 id="服务端路由（entry-server-js）："><a href="#服务端路由（entry-server-js）：" class="headerlink" title="服务端路由（entry-server.js）："></a>服务端路由（entry-server.js）：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createApp = <span class="function">(<span class="params">context, url, store</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;StaticRouter context=&#123;context&#125; location=&#123;url&#125;&gt;</span><br><span class="line">          &lt;Root /&gt;</span><br><span class="line">        &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export &#123;</span></span><br><span class="line"><span class="xml">  createApp,</span></span><br><span class="line"><span class="xml">  createStore,</span></span><br><span class="line"><span class="xml">  router</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router 针对服务器端渲染专门提供的一个路由组件。）</p>
<h1 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h1><p>对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的。换句话说，Entry 的配置肯定是不同的。所以我们需要打包出两份代码，一份由服务端执行渲染html，一份由浏览器执行，两份代码里大部分代码都可以在服务端和客户端执行（不然怎么能叫同构应用呢）。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/13276697-fd85a3da3c6ec8a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|---build   - 工程构建目录，包含了，开发，测试以及上线中所用到的构建脚本及插件</span><br><span class="line">    |---plugins   - 构建中所用到的自定义插件</span><br><span class="line">    |---webpack.base.config.js    - 通用 webpack 配置</span><br><span class="line">    |---webpack.dev.config.js     - 客户端开发环境 webpack 配置</span><br><span class="line">    |---webpack.prod.config.js    - 客户端生产环境 webpack 配置</span><br><span class="line">    |---webpack.dll.config.js     - 客户端 webpack dll 配置</span><br><span class="line">    |---webpack.server.config.js  - 服务端 webpack 配置</span><br><span class="line">    |---webpack.test.config.js    - 客户端测试环境 webpack 配置</span><br><span class="line">|---config  - 构建配置文件，包含静态资源路径，接口代理地址等</span><br></pre></td></tr></table></figure></p>
<h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>这么多 webpack 配置文件里，其实只有 webpack.server.config.js 是给服务端用的，因为服务端配置无需区分开发环境还是生成环境。<br>服务端运行于 node 中，不支持 babel，不支持样式，同时也不支持一些浏览器全局对象如 window、document，对于 babel 使用 babel-loader 进行转换，对于样式使用插件提取出来，服务端只运行 js 生成 html 片段，再根据客户端清单将 css 插入到 head 中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> SSRServerPlugin = <span class="built_in">require</span>(<span class="string">'./plugins/server-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: utils.resolve(<span class="string">'src/entry-server.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: <span class="string">'entry-server.js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  target: <span class="string">'node'</span>, <span class="comment">// 指定node运行环境</span></span><br><span class="line">  devtool: config.server.devtool,</span><br><span class="line">  externals: [</span><br><span class="line">    nodeExternals(&#123;</span><br><span class="line">      whitelist: [ <span class="regexp">/\.(css|sass)$/</span> ] <span class="comment">// 忽略css，让webpack处理</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              babelrc: <span class="literal">false</span>,</span><br><span class="line">              presets: [<span class="string">'@babel/preset-env'</span>, <span class="string">'@babel/preset-react'</span>],</span><br><span class="line">              plugins: [</span><br><span class="line">                <span class="string">'dynamic-import-node'</span>,</span><br><span class="line">                <span class="string">'@loadable/babel-plugin'</span></span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ...utils.styleLoaders(&#123;</span><br><span class="line">        sourceMap: config.build.productionSourceMap,</span><br><span class="line">        extract: <span class="literal">true</span>,</span><br><span class="line">        usePostCSS: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: config.server.env</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: utils.assetsPath(<span class="string">'css/[name].[contenthash].css'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 这是将服务器的整个输出</span></span><br><span class="line">    <span class="comment">// 构建为单个 JSON 文件的插件</span></span><br><span class="line">    <span class="keyword">new</span> SSRServerPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'server-bundle.json'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端配置是有必要区分开发环境和生产环境的（我们先忽略测试环境配置），开发环境我们增加热更新、source-map、eslint 等功能，而生产环境我们将侧重 webpack 分包及样式提取上。</p>
<h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add hot-reload related code to entry chunks</span></span><br><span class="line"><span class="built_in">Object</span>.keys(baseWebpackConfig.entry).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  baseWebpackConfig.entry[name] = [</span><br><span class="line">    <span class="string">'react-hot-loader/patch'</span>,</span><br><span class="line">    <span class="string">'webpack-hot-middleware/client'</span></span><br><span class="line">  ].concat(baseWebpackConfig.entry[name]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createLintingRule = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">  loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">  enforce: <span class="string">'pre'</span>,</span><br><span class="line">  include: [utils.resolve(<span class="string">'src'</span>)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>),</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.dev.assetsRoot,</span><br><span class="line">    filename: utils.assetsPath(<span class="string">'js/[name].js'</span>),</span><br><span class="line">    publicPath: config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      createLintingRule(),</span><br><span class="line">      ...utils.styleLoaders(&#123; <span class="attr">sourceMap</span>: config.dev.cssSourceMap, <span class="attr">usePostCSS</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: config.dev.devtool,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: config.dev.env</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.config'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: utils.assetsPath(<span class="string">'js/[name].[chunkhash].js'</span>),</span><br><span class="line">    publicPath: config.build.assetsPublicPath,</span><br><span class="line">    chunkFilename: utils.assetsPath(<span class="string">'js/[id].[chunkhash].js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      extract: <span class="literal">true</span>,</span><br><span class="line">      usePostCSS: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: config.build.devtool,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'manifest'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        chunks: <span class="string">'initial'</span>,</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/([\\/]node_modules[\\/])/</span>,</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'async-vendors'</span>: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          minChunks: <span class="number">3</span>,</span><br><span class="line">          chunks: <span class="string">'async'</span>,</span><br><span class="line">          name: <span class="string">'async-vendors'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        sourceMap: <span class="literal">true</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">        cssProcessorOptions: &#123;</span><br><span class="line">          map: &#123; <span class="attr">inline</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: config.build.env</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: utils.assetsPath(<span class="string">'css/[name].[contenthash].css'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// keep module.id stable when vendor modules does not change</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    <span class="comment">// enable scope hoisting</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Node-服务"><a href="#Node-服务" class="headerlink" title="Node 服务"></a>Node 服务</h1><p>在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。<br>这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。</p>
<p>服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。</p>
<p>这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。</p>
<p>在 server/index.js 中我们使用 express 启动 Node 服务，处理任何 get 请求。从服务端打包后的 js 中获取根组件，读取的 index.html 模板，调用 renderToString 传入根组件，将返回的 html 字符串替换掉模板中占位符，返回到客户端。</p>
<h2 id="server-index-js"><a href="#server-index-js" class="headerlink" title="server/index.js"></a>server/index.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>);</span><br><span class="line"><span class="keyword">const</span> opn = <span class="built_in">require</span>(<span class="string">'opn'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> ServerRenderer = <span class="built_in">require</span>(<span class="string">'./renderer'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态资源映射到dist路径下</span></span><br><span class="line">app.use(express.static(<span class="string">'dist'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">'production'</span>;</span><br><span class="line"><span class="keyword">let</span> renderer;</span><br><span class="line"><span class="keyword">let</span> readyPromise;</span><br><span class="line"><span class="keyword">let</span> template = fs.readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="keyword">if</span> (isProd) &#123;</span><br><span class="line">  <span class="keyword">let</span> bundle = <span class="built_in">require</span>(<span class="string">'../dist/server-bundle.json'</span>);</span><br><span class="line">  <span class="keyword">let</span> stats = <span class="built_in">require</span>(<span class="string">'../dist/loadable-stats.json'</span>);</span><br><span class="line">  renderer = <span class="keyword">new</span> ServerRenderer(bundle, template, stats);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  readyPromise = <span class="built_in">require</span>(<span class="string">'./dev-server'</span>)(app, (bundle, stats) =&gt; &#123;</span><br><span class="line">    renderer = <span class="keyword">new</span> ServerRenderer(bundle, template, stats);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chalk.cyan(<span class="string">'visit url: '</span> + req.url));</span><br><span class="line"></span><br><span class="line">  renderer.renderToString(req).then(<span class="function">(<span class="params">&#123; error, html &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error.url) &#123;</span><br><span class="line">        res.redirect(error.url);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.code) &#123;</span><br><span class="line">        res.status(error.code).send(<span class="string">'error code：'</span> + error.code);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.send(html);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    res.status(<span class="number">500</span>).send(<span class="string">'Internal server error'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'*'</span>, isProd ? render : <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 等待客户端和服务端打包完成后进行render</span></span><br><span class="line">  readyPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> render(req, res));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || config.dev.port;</span><br><span class="line"><span class="keyword">const</span> autoOpenBrowser = !!config.dev.autoOpenBrowser;</span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">'http://localhost:'</span> + port;</span><br><span class="line"><span class="keyword">const</span> ip = <span class="string">'http://'</span> + <span class="built_in">require</span>(<span class="string">'ip'</span>).address() + <span class="string">':'</span> + port;</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(chalk.cyan(<span class="string">'\n'</span> + <span class="string">'- Local: '</span> + uri + <span class="string">'\n'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(chalk.cyan(<span class="string">'- On your Network: '</span> + ip + <span class="string">'\n'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (autoOpenBrowser) &#123;</span><br><span class="line">    opn(uri);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们仍需区分开发环境和生产环境，因为开发环境我们需要增加热更新的代码逻辑。<br>在 server/index.js 中判断当前环境是否是生产环境，生产环境保持原有的逻辑，非生产环境使用 webpack-dev-middleware 和 webpack-hot-middleware 进行客户端热更新。<br>服务端热更新则需要使用 outputFileSystem 属性指定打包输出的文件系统为内存文件系统，再使用watch函数检测文件变动，打包完成后同样从内存中获取 server-bundle.json 文件内容。</p>
<h2 id="server-dev-server-js"><a href="#server-dev-server-js" class="headerlink" title="server/dev-server.js"></a>server/dev-server.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> MFS = <span class="built_in">require</span>(<span class="string">'memory-fs'</span>);</span><br><span class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">'../build/webpack.dev.config'</span>);</span><br><span class="line"><span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">'../build/webpack.server.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">setupDevServer</span>(<span class="params">app, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bundle;</span><br><span class="line">  <span class="keyword">let</span> loadableStats;</span><br><span class="line">  <span class="keyword">let</span> resolve;</span><br><span class="line">  <span class="keyword">const</span> readyPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123; resolve = r; &#125;);</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bundle &amp;&amp; loadableStats) &#123;</span><br><span class="line">      callback(bundle, loadableStats);</span><br><span class="line">      resolve(); <span class="comment">// resolve Promise让服务端进行render</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> readFile = <span class="function">(<span class="params">fs, fileName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(path.join(clientConfig.output.path, fileName), <span class="string">'utf-8'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端打包</span></span><br><span class="line">  <span class="keyword">const</span> clientCompiler = webpack(clientConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用webpack-dev-middleware中间件服务webpack打包后的资源文件</span></span><br><span class="line">  <span class="keyword">const</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)(clientCompiler, &#123;</span><br><span class="line">    publicPath: clientConfig.output.publicPath,</span><br><span class="line">    logLevel: <span class="string">'warn'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  app.use(devMiddleware);</span><br><span class="line"></span><br><span class="line">  clientCompiler.hooks.done.tap(<span class="string">'done'</span>, stats =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> info = stats.toJson();</span><br><span class="line">    <span class="keyword">if</span> (stats.hasWarnings()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(info.warnings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stats.hasErrors()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(info.errors);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loadableStats = <span class="built_in">JSON</span>.parse(readFile(devMiddleware.fileSystem, <span class="string">'loadable-stats.json'</span>));</span><br><span class="line">    update();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 热更新中间件</span></span><br><span class="line">  app.use(<span class="built_in">require</span>(<span class="string">'webpack-hot-middleware'</span>)(clientCompiler));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监视服务端打包入口文件，有更改就更新</span></span><br><span class="line">  <span class="keyword">const</span> serverCompiler = webpack(serverConfig);</span><br><span class="line">  <span class="comment">// 使用内存文件系统</span></span><br><span class="line">  <span class="keyword">const</span> mfs = <span class="keyword">new</span> MFS();</span><br><span class="line">  serverCompiler.outputFileSystem = mfs;</span><br><span class="line">  serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> info = stats.toJson();</span><br><span class="line">    <span class="keyword">if</span> (stats.hasWarnings()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(info.warnings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stats.hasErrors()) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(info.errors);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bundle = <span class="built_in">JSON</span>.parse(readFile(mfs, <span class="string">'server-bundle.json'</span>));</span><br><span class="line">    update();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> readyPromise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>最后我们对 package.json 进行修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"node server/index.js"</span>,</span><br><span class="line">    <span class="string">"dll"</span>: <span class="string">"webpack --config build/webpack.dll.config.js"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node server/index.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server"</span>,</span><br><span class="line">    <span class="string">"build:client"</span>: <span class="string">"webpack --config build/webpack.prod.config.js"</span>,</span><br><span class="line">    <span class="string">"build:server"</span>: <span class="string">"webpack --config build/webpack.server.config.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="本地启动工程"><a href="#本地启动工程" class="headerlink" title="本地启动工程"></a>本地启动工程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初次配置需要执行，生成 vendor.dll 文件</span></span><br><span class="line">npm run dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动工程</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h2 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用生产环境配置打包</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动工程</span></span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，整个 React 同构体系中关键知识点的原理就串联起来了。<br>当然，本文所涉及的同构知识还是非常有限，下一篇中我还将介绍同构中异步数据的获取 + Redux 的使用。<br>如果你看了文章觉得云里雾里，可以将代码自行 fork 下来跑一跑，我相信可以帮助到你。<br>工程地址：<a href="https://github.com/LiuLingyang/react-ssr-framework" target="_blank" rel="noopener">https://github.com/LiuLingyang/react-ssr-framework</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/26/2018/你可能需要 Redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/26/2018/你可能需要 Redux/" itemprop="url">
                  你可能需要 Redux
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T00:00:00+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redux/" itemprop="url" rel="index">
                    <span itemprop="name">Redux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/26/2018/你可能需要 Redux/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/09/26/2018/你可能需要 Redux/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你可能并不需要Redux。<br>有点啪啪打脸的意思，但你必须权衡Redux架构给你项目带来的短期和长期的效益来决定是否应该使用Redux。如果只是一个简单的应用，Redux只会带来繁琐冗余的代码体验，这真的得不偿失。如果打算开发大型单页应用，Redux将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>
<blockquote>
<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>
</blockquote>
<h1 id="Why-Redux"><a href="#Why-Redux" class="headerlink" title="Why Redux"></a>Why Redux</h1><p>当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。<br>通俗点说如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。<br>以前我们试图用事件广播来避免这些连锁反应，但随之而来的问题是，在应用不断的扩展、变化中，广播事件也变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。<br>这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。<br>于是Redux应运而生。</p>
<h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p><img src="https://upload-images.jianshu.io/upload_images/13276697-c94158eb9114e4e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>单向数据流可以说是Redux的设计核心。上图是一个表示“单向数据流”理念的极简示意。单向数据流要求各组件间的数据走向永远是单向的，可预期的。你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交Actions。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够更好地了解我们的应用。</p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p>Action是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过store.dispatch() 将 action 传到 store。你可以理解为这是一个修改数据的指令。<br>为什么要用Action？<br>store的数据操作封装在store内部，各组件禁止直接修改state数据，只能发布一个修改数据的意图通知store进行数据更新，这个意图就是Action。<br>按照约定，action 具有 type 字段来表示它的类型。type 可被定义为常量或者是从其它模块引入，最好使用字符串。除了 type 字段外，action 对象的结构完全取决于你。<br>为了使Action可复用，我们最好编写Action创建函数。</p>
<h1 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h1><p>Redux中的数据处理部分，我们称之为Reducer。<br>Reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。<br>纯函数定义：相同的输入一定会对应相同的输出。翻译过来就是只要传入Action相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。<br>特别注意：不要修改 state。可以使用 Object.assign() 新建了一个副本或者借助Immutable.js。<br>Reducer过大时可以拆分Reducer。让每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。</p>
<h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><p> Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合，而不是创建多个 store。<br>你可以通过createStore()接口创建你的store，第一个参数就是之前组合好的reducer，第二个参数用于设置 state 初始状态。第三个参数是一个高阶函数，主要用于Middleware。<br>store主要职责：</p>
<ul>
<li>提供 getState() 方法获取 state；</li>
<li>提供 dispatch(action)方法更新 state；</li>
<li>通过subscribe(listener) 注册监听器;</li>
</ul>
<h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h1><p>Middleware提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。 你可以利用 Middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。<br>Redux middleware 就像一个链表。每个 middleware 方法既能调用 next(action) 传递 action 到下一个 middleware，也可以调用 dispatch(action) 重新开始处理，或者什么都不做而仅仅终止 action 的处理进程。<br>创建 store 时， applyMiddleware 方法的入参定义了 middleware 链，你只需要按照规定的格式编写你自己的Middleware即可。<br>applyMiddleware 实现原理其实很简单，代理store.dispatch，在调用前后插入自己的逻辑。</p>
<h1 id="reducer-enhancer"><a href="#reducer-enhancer" class="headerlink" title="reducer enhancer"></a>reducer enhancer</h1><p>reducer enhancer作为一个函数，接收 reducer 作为参数并返回一个新的 reducer，这个新的 reducer 可以处理新的 action，或者维护更多的 state，亦或者将它无法处理的 action 委托给原始的 reducer 处理。<br>reducer enhancer可以看做是reducer的扩展，主要职责：</p>
<ul>
<li>统一修正reducer处理后的数据</li>
<li>统一计算reducer处理后的计算属性</li>
<li>实现撤销重做</li>
</ul>
<h1 id="Ending…"><a href="#Ending…" class="headerlink" title="Ending…"></a>Ending…</h1><p>想要讲清楚Redux不是一件容易的事，文章也只是介绍了Redux的一些基本概念。<br>要想真正理清Redux，对应的项目经验是必不可少的。<br>如果你还在用low爆了的中介者模式或者难以管理的事件广播的话，强烈推荐迁移成Redux，你会发现一片不一样的天空。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/14/2018/老调重弹 webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/14/2018/老调重弹 webpack/" itemprop="url">
                  老调重弹 webpack
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T00:00:00+08:00">
                2018-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Webpack/" itemprop="url" rel="index">
                    <span itemprop="name">Webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/14/2018/老调重弹 webpack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/06/14/2018/老调重弹 webpack/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本来是准备只总结下热更新的，但发现webpack4升级后还是有不少改动，索性放在一起总结一下。<br>按照惯例，先上链接：<a href="https://github.com/LiuLingyang/framework" target="_blank" rel="noopener">https://github.com/LiuLingyang/framework</a>。（注：该脚手架基于 webpack4 ）</p>
<h1 id="多入口多出口"><a href="#多入口多出口" class="headerlink" title="多入口多出口"></a>多入口多出口</h1><p>在大家熟知的脚手架中，大部分可能都是单页面应用，即单入口单出口。当你的网站足够简单，SPA确实提高了用户体验。但对于企业级应用而言，SPA极易造成单个页面体积过大，它可能加载了很多其他页面的资源。SPA的另一个问题就是不利于SEO。针对这些问题，多页面 + 局部SPA 成为了最优的选择。</p>
<p>多页面大多数情况有多个html模板文件，并且要求引入各自的JS文件配置，即多入口多出口。如何生成多个页面？只要以链式的方法，调用html-webpack-plugin插件，每次调用都要指定filename也就是生成页面的名字。调用一次生成一个页面，调用两次生成两个页面,以此类推。</p>
<p>如何引入各自的JS文件配置？比如说我们希望index.html引入的是index.js，test.html引入的是test.js如何操作呢？<br>我们需要在html-webpack-plugin中再配置一个参数，chunks，支持数组，数组里面填写的是引入的js，也就是entry里面配置的key，要引入哪个js就配置entry中的哪个key。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/13276697-10a11c392da5f96e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<h1 id="开发环境？生产环境？"><a href="#开发环境？生产环境？" class="headerlink" title="开发环境？生产环境？"></a>开发环境？生产环境？</h1><p>ebpack4中提供了更加快捷的mode模式来区分开发环境和生产环境。mode有两个值：development和production，默认值是 production。mode是我们为减小生产环境构建体积以及节约开发环境的构建时间提供的一种优化方案，提供对应的构建参数项的默认开启或关闭，降低配置成本。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/13276697-2094665814acff8f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"><br> <img src="http://upload-images.jianshu.io/upload_images/13276697-4c1d7d5b3726a079?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>development模式下，将侧重于功能调试和优化开发体验。<br>production模式下，将侧重于模块体积优化和线上部署。注意：这里不再需要配置UglifyJSPlugin插件，而是会自动启用uglifyjs对代码进行压缩。</p>
<h1 id="webpack4其他改动"><a href="#webpack4其他改动" class="headerlink" title="webpack4其他改动"></a>webpack4其他改动</h1><p>webpack4官方移除了commonchunk插件，改用了optimization属性进行更加灵活的配置，这也应该是从V3升级到V4的代码修改过程中最为复杂的一部分。</p>
<p>由于webpack4以后对css模块支持的逐步完善和commonchunk插件的移除，在处理css文件提取的计算方式上也做了些调整，之前我们首选使用的extract-text-webpack-plugin也完成了其历史使命，将让位于mini-css-extract-plugin。</p>
<p>剩下的问题大部分都是因为当前的包与webpack4不兼容。解决办法：升级呗。</p>
<p>这里就不贴出详细代码了，看源码吧。</p>
<h1 id="模块热替换-Hot-Module-Replacement"><a href="#模块热替换-Hot-Module-Replacement" class="headerlink" title="模块热替换(Hot Module Replacement)"></a>模块热替换(Hot Module Replacement)</h1><p>HMR是webpack最令人兴奋的特性之一，当你对代码进行修改并保存后，webpack将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。HMR是一个非常值得去深入研究的东西，它绝不是目前我们看到的大多数技术文章说的配置一个hot参数这么简单，有兴趣的小伙伴可以去看看它的实现原理，目前为止我也只看过一点点。</p>
<p>实现模块热替换的方式有两种，一种是采用中间件的方式，webpack-dev-middleware和webpack-hot-middleware配合使用，实现热替换功能；另外一种是使用webpack-dev-server插件，配置一些必要的参数，也可以实现热替换功能。需要注意的是两种方式都只用于开发环境。打包后的文件都是放到内存中的，所以我们在项目中是看不到它打包以后生成的文件的。本例采用第二种方式实现。</p>
<p>两种方式都需要配置的项我就放在最前面说好了：</p>
<ol>
<li><p>webpack的plugins添加webpack.HotModuleReplacementPlugin()，这是一个必要的热替换插件。你可能在某些地方可能会看到webpack-dev-server添加了hot: true以后，它会自动帮我们加这个插件。相信我，还是会报错的，所以还是老老实实的手动添加到plugins里面吧。</p>
</li>
<li><p>我们通过 HotModuleReplacementPlugin 启用了模块热替换，则它的接口将被暴露在module.hot属性下面。我们需要把整个项目的要被webpack编译的文件都设置为接受热更新，而最简单的方式就是在入口文件的地方添加：<br><img src="http://upload-images.jianshu.io/upload_images/13276697-205f22821d59a879?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
</li>
</ol>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件的方式配置起来还是比较简单的。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/13276697-685718606099b7ba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>就这几行核心代码，我就直接贴出来了。</p>
<p>中间件是可以和自己的后端服务整合的，相对与webpack-dev-server，它拥有更好的灵活性和自由度。</p>
<p>Koa实现热更新的中间件似乎还没有包可以直接引，但大神们早已为我们铺好了路。Kao架构可以参考：<a href="https://www.cnblogs.com/liuyt/p/7217024.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuyt/p/7217024.html</a></p>
<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server实际上相当于启用了一个express的Http服务器+调用webpack-dev-middleware。它的作用主要是用来伺服资源文件。这个Http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会用webpack实时的编译，再用webpack-dev-middleware将webpack编译后文件输出到内存中。</p>
<p>webpack-dev-server支持两种配置方式（iframe mode &amp;&amp; inline mode）。</p>
<p>iframe模式不需要配置任何东西，只需要在你启动的项目的端口号后面加上/webpack-dev-server/即可，比如：<a href="http://localhost:8080/webpack-dev-server/。" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server/。</a><br>它的原理是在页面中嵌入了一个iframe标签来实现热更新。因为这种模式配置比较简单，这里就不展开介绍这种模式了。有兴趣的小伙伴可以自行研究。</p>
<p>inline模式不需要改变url，但配置起来比iframe模式繁琐的多。</p>
<p>inline模式又分两种方式启动，Node方式和非Node方式。</p>
<p>#非Node方式<br>非Node方式有关webpack-dev-server的配置都在webpack.config.js的devServer参数里。一定要指定output.publicPath，如果不指定会导致HMR无法工作。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/13276697-387aa53641c0c109?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>contentBase就和output.path是一样的作用，如果不配置这个参数就会打包到项目的根路径下。这里再强调一下为了加快打包进程打包后的文件是放到内存中的，所以我们是看不到实际文件的。</p>
<p>hot:true&amp;&amp;inline:true就是开启inline模式和热更新，没什么好说的。</p>
<p>proxy：当您有一个单独的后端开发服务器，并且想要在同一个域上发送API请求时，则代理这些url。设置代理后contentBase需要修改为绝对路径。本例中将被修改为<a href="http://localhost:3001/。" target="_blank" rel="noopener">http://localhost:3001/。</a></p>
<p>命令行启动：webpack-dev-server –hot –inline。</p>
<h2 id="Node方式"><a href="#Node方式" class="headerlink" title="Node方式"></a>Node方式</h2><p>如果使用Node.js方式，那么即使你配置了devServer也会被忽略，真正起作用的应该是Node.js的dev.js文件，这个文件放在build目录下面。<br>此时启动项目：node build/dev.js。</p>
<p>build/dev.js<br> <img src="http://upload-images.jianshu.io/upload_images/13276697-dcf1a45bf94c1db9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>当然这还不够，还需要在entry属性里添加webpack-dev-server/client?http://«path»:«port»/ 和 webpack/hot/dev-server。<br> <img src="http://upload-images.jianshu.io/upload_images/13276697-1e035f357e5263bf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>好的，选择一个你喜欢的方式启动起来吧，如果能在控制台看到以下的信息，代表热更新已经成功启动了。<br> <img src="http://upload-images.jianshu.io/upload_images/13276697-8175752ec6f67443?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<h2 id="react-hot-loader"><a href="#react-hot-loader" class="headerlink" title="react-hot-loader"></a>react-hot-loader</h2><p>你可以已经注意到了，在entry属性中我还添加了react-hot-loader/patch。</p>
<p>webpack-dev-server的热更新对于保存react状态是无法做到的，所以才有了react-hot-loader这个东西，这个不是必须配置的插件。<br>不过如果你想要更新时可以保存state，这是必须的。</p>
<p>配置分三步走：</p>
<p>1..babelrc中添加react-hot-loader/babel：<br> <img src="http://upload-images.jianshu.io/upload_images/13276697-1dd57addaef0f156?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>2.entry参数添加react-hot-loader/patch；</p>
<p>3.修改跟组件接收热更新：<br> <img src="http://upload-images.jianshu.io/upload_images/13276697-7ea145c9d4e00bbd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt pic"></p>
<p>经过一顿神操作后，相信你已经弄清楚了热更新到底是怎么回事。如果你的项目还没有开始应用，抓紧尝试下吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/2018/Vuex 实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/11/2018/Vuex 实践/" itemprop="url">
                  Vuex 实践
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T00:00:00+08:00">
                2018-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/11/2018/Vuex 实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/01/11/2018/Vuex 实践/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2017年对于Vue注定是不平凡的一年。凭借着自身简介、轻量、快速等特点，Vue俨然成为最火的前端MVVM开发框架。随着Vue2.0的release，越来越多的项目开始采用Vue作为他们的前端框架。而作为Vue生态中最重要的一环，Vuex渐渐进入大家的视野。</p>
<h1 id="数据管理模式"><a href="#数据管理模式" class="headerlink" title="数据管理模式"></a>数据管理模式</h1><p>在正式开始介绍Vuex之前，有必要介绍一下数据管理模式的前世今生。</p>
<p>当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。以前我们试图用事件广播来做，但随之而来的问题是，在应用不断的扩展、变化中，事件变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。于是数据管理模式应运而生。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-ade5772825adcf0a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>  图1</p>
<p>图1是最简单的组件关系，b是a的子组件，而c是b的子组件。在我们不引入任何数据管理模式之前，c组件要拿到a组件的数据只能由a先传给b，在由b传给c。如果组件树变得复杂，可想而知这将是一场灾难。看似严谨的父子结构其实严格限制了数据的流动方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-94ea04d5ddad1c1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>  图2</p>
<p>图2是最简单的数据管理模式，所有数据将统一交给全局store来管理。a和c组件现在直接修改store里的数据，并且通过mapState从store中抓取自己感兴趣的数据到自己的组件中。而b组件，如果它对a、c组件的数据毫无兴趣，则可以做到完全解耦。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-374b973e1101f3d3?imageMogr2/auto-orient/strip" alt="image"></p>
<p>  图3</p>
<p>随着数据管理的进一步发展和演变，有一种叫单向数据流的东西冒了出来。图3就是一个表示“单向数据流”理念的极简示意。单向数据流要求各组件间的数据走向永远是单向的，可预期的。你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交Actions。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够更好地了解我们的应用。</p>
<p>这次我们的主人公Vuex可以说是单向数据流的最佳实践者。</p>
<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。Vuex背后的基本思想，就是前面所说的单向数据流。图4就是Vuex实现单向数据流的示意图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-aabd7a9c819cdbe1?imageMogr2/auto-orient/strip" alt="image"></p>
<p>  图4</p>
<p>接下来，我们将会更深入地探讨一些核心概念。让我们先从Store概念开始。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state) 。</p>
<p>安装 Vuex 之后，让我们来创建一个最简单的 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-88987b3719dad698?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-2cab0905bc826369?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
<p>那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-eadfef0c06f06aa6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-492cc3d42023b7b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>
<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-dc45b1a528c34f5c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Getter 会暴露为 store.getters 对象：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-88971c42880736f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><p>Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数(handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，payload作为第二个参数（额外的参数）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-e8b95350bd88ffe4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>一条重要的原则就是要记住 mutation 必须是同步函数。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 类似于 mutation，不同在于：</p>
<pre><code>1.Action 提交的是 mutation，而不是直接变更状态。 

2.Action 可以包含任意异步操作。
</code></pre><p>让我们来注册一个简单的 action：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-4b23f98f12b9b7ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>
<p>我们可以在 action 内部执行异步操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-e50c2eb59936deb1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="今天的目标"><a href="#今天的目标" class="headerlink" title="今天的目标"></a>今天的目标</h1><p><img src="http://upload-images.jianshu.io/upload_images/13276697-e2d3ca07eb8312ff?imageMogr2/auto-orient/strip" alt="image"></p>
<p>这是一个记忆小游戏，来自leftstick的vue-memory-game，github地址：<a href="https://github.com/leftstick/vue-memory-game" target="_blank" rel="noopener">https://github.com/leftstick/vue-memory-game</a>。今天我们就这个小游戏来详细讲解下vuex的实现。</p>
<h2 id="组件分解"><a href="#组件分解" class="headerlink" title="组件分解"></a>组件分解</h2><p><img src="http://upload-images.jianshu.io/upload_images/13276697-e8b0d5e8ba09621c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我们根据分解图，先把要实现的组件挨个儿列出来：</p>
<ol>
<li>Game, 最外层的游戏面板</li>
<li>Dashboard, 上面的logo，游戏进度，最佳战绩的容器</li>
<li>Logo，左上角的logo</li>
<li>MatchInfo, 正中上方的游戏进度组件</li>
<li>Score, 右上角的最佳战绩组件</li>
<li>Chessboard, 正中大棋盘</li>
<li>Card, 中间那十六个棋牌</li>
<li>PlayStatus, 最下方的游戏状态信息栏</li>
</ol>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="http://upload-images.jianshu.io/upload_images/13276697-1571af221c8661a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>让我们聚焦红框中关于Vuex的这一部分。接下来我们将结合Card.vue和Chessboard.vue这两个核心组件进行。</p>
<p>store/index.js</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-81de916d03bbe53c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>store的创建并没有什么复杂的逻辑，而state就是这个项目需要维护的整个数据。初始化cards的结构我简要的整合了一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-526b7edad9b6ad08?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>你可以选择初始化store的时候直接带进去，也可以像作者一样从入口处reset一遍数据，这里就不详细展开了。</p>
<p>Chessboard.vue</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-39e5fff4e1c20cf1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-99765d410a01d8df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>Card.vue</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-ed6ad752f456dafc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>我在源码上增加了一些注释，方便大家理解。</p>
<p>mapGetter和mapActions只是一些辅助函数，可以减少一些this.$store和dispatch action之类比较重复的代码，这些辅助函数可以帮助vuex应用的更加简便。</p>
<p>相比与这些可有可无的噱头，我们更关心卡片被点击的时候发生了什么？this.flipCard()后数据流向了哪里？</p>
<p>数据流动</p>
<p>当卡片被点击时，vue component 实则 dispatch出了一个action，而我们的数据，作为载荷（参数），也只能随波逐流了。</p>
<p>他首先来到了第一站：actions，然而actions却说你不需要什么异步处理，可以去下一站了。（如果没有异步操作，其实可以少走一站）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-cfb3f0e7940642cd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p> actions处理函数</p>
<p>数据没有灰心，很快他就来到了mutaions。</p>
<p>mutaions欣喜若狂：你在这等着，待我处理好了你再上路。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-070fb12b6e9473e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p> mutations处理函数</p>
<p>不一会，数据就改头换面了，但如何告诉vue components我发生变化了呢？迷茫的数据找到了getter。getter哈哈大笑：你在我这的状态存储是响应式的，只要vue components在计算属性中应用了你，他们就能第一时间知道你的状态变更哦。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-fd410e388dd6700f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>  getter生成计算属性（如果没有派生出其他状态，可以不用getter）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-ea97acce2a1d6b45?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p> components状态更新</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>通过这个记忆小游戏，希望大家对Vuex有一个基本的理解。如果你熟悉Redux的话，掌握Vuex应该不难，因为Vuex和Redux基本思想是一致的，实现方式也是大同小异。但Vuex只适用于Vue，没有Redux那么泛用罢了。关于Vue和Vuex的问题，欢迎交流~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/2017/vue 生态圈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/02/2017/vue 生态圈/" itemprop="url">
                  vue 生态圈
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T00:00:00+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/02/2017/vue 生态圈/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/09/02/2017/vue 生态圈/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司社区上关于Vue的文章挺少的（少的可怜），不禁为Vue愤愤不平，此文应运而生。</p>
<p>但笔者水平有限，也写不了什么特别高深的东西，只能简单介绍下Vue生态圈，如有不对之处，还望指正。</p>
<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>Vue.js是一款极简的 mvvm 框架，如果让我用一个词来形容它，就是“轻巧”。如果用一句话来描述它，它能够集众多优秀逐流的前端框架之大成，但同时保持简单易用。为什么这么说，因为Vue.js通过简洁的API提供高效的数据绑定和灵活的组件系统。在前端纷繁复杂的生态中，Vue.js却一直受到一定程度的关注，而其本身也在高速发展中，不论是生态、社区、资源、插件等等都在日趋壮大。如果您还未曾了解Vue.js的话，建议您阅读<a href="http://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">http://cn.vuejs.org/v2/guide/</a>，这里有Vue.js正确的食用方法。如果您想在此文中知晓Vue.js核心的话，可能要让您失望了。本文不会介绍Vue.js的语法，模板、组件、API等等，这是一篇介绍Vue.js周边或者说Vue.js生态的文章（当然这要求你对Vue.js有一定程度的了解）。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。灵感来自Flux和Redux,但简化的概念和实现是一个专门为<code>Vue.js</code>应用设计的状态管理架构。如果您的应用程序足够简单，建议您不要使用Vuex。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p>
<p>言归正传，什么是状态管理模式？讲讲我自己的理解吧。当你在开发应用程序时，你一定会分解出很多组件进行开发，而各个组件之间想必在逻辑上多少是有关系的。那么组件之间的“通信”，就成了待解决问题。以前我们试图用事件广播来做，但随之而来的问题是，在应用不断的扩展、变化中，事件变得越来越复杂，越来越不可预料，以至于越来越难调试，越来越难追踪错误。这当然不是我们想要的，我们希望应用的各个部分都易维护、可扩展、好调试、能预测。于是，状态管理模式冒了出来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-dc8081d4ab35469b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>几个重要的概念：</p>
<ul>
<li>state：驱动应用的数据源；</li>
<li>actions：响应在用户操作行为导致的状态变化；</li>
<li>mutations：引发状态改变的所有方法的集合；</li>
<li>store对象：store对象是Vuex.Store的实例。在store内有分为state对象和mutations对象。</li>
</ul>
<p>简单点说，本来需要共享状态的更新是需要组件之间通讯的，而现在有了Vuex，所有组件就都和store通讯了。问题就自然解决了。</p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>都说Vue牛逼，那一定也有一套自己路由的实现，接下来让我们来看看vue-router。</p>
<p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。</p>
<p>vue-router的用法也是异常简单：</p>
<p><strong>HTML</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入`to`属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个`&lt;a&gt;`标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>JS</strong></p>
<pre data-type="javascript">
0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)

1. 定义（路由）组件
// 可以从其他文件 import 进来
const Foo = { template: 'foo' }
const Bar = { template: 'bar' }

2. 定义路由
// 每个路由应该映射一个组件。 其中"component" 可以是通过 Vue.extend() 创建的组件构造器，或者，只是一个组件配置对象。
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]

3. 创建 router 实例，然后传 `routes` 配置
const router = new VueRouter({
  routes // （缩写）相当于 routes: routes
})

4. 创建和挂载根实例
// 记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能
const app = new Vue({
  router
}).$mount('#app')
</pre>

<p>现在，你已经完成了整个应用的路由配置，到浏览器上看看效果吧！</p>
<h2 id="vue-devtools"><a href="#vue-devtools" class="headerlink" title="vue-devtools"></a>vue-devtools</h2><p>vue-devtools是基于google chrome浏览器的一款调试vue.js应用的开发者浏览器扩展。一张图看懂它是什么：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-69008de1aea50cab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>注意：初次安装好vue-devtools以后，需要关闭chrome devtool再开，才能看见vue的标签（通常在最后）。如果你正在使用我提供的例子，或者同样也是在浏览器访问自己本机写的html，需要在vue-devtools的设置里面勾选“允许访问文件URL”（如图）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-377be978a9d309c4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>把webpack放在这里讲似乎不太合适，毕竟这并不是Vue独有的东西。而且webpack的大名说不定比Vue本身还响亮。看近期Github上各大主流的项目，无一例外都已经是基于webpack来开发。你可以不打算将其用在你的项目上，但没有理由不去掌握它。篇幅有限，不展开描述，一句话概括webpack的主要用途：把所有浏览器端需要发布的资源做相应的准备，完成资源的合并和打包。</p>
<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>作为Vue的脚手架，vue-cli无疑是出色的。它可以帮你快速的上手vue构建的工程，而无需再花多余的时间去熟悉vue工程的文件系统。</p>
<p>使用它的方法也很简单：</p>
<ol>
<li>npm install -g vue-cli      //全局安装vue-cli</li>
<li>vue init webpack projectName  //生成项目名为projectName的模板，这里的项目名projectName随你自己写</li>
<li>cd projectName                              </li>
<li>npm install             //初始化安装依赖</li>
<li>npm run dev            //启动工程</li>
</ol>
<p>在浏览器打开<a href="http://localhost:8080，则可以看到欢迎页了：" target="_blank" rel="noopener">http://localhost:8080，则可以看到欢迎页了：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-319302c2973f3f2f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>再回头看看项目结构，是不是一目了然:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-40879b0df04378e0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h2><p>其实这是Vue.js的一个ui库，我一直不明白为什么作者不直接把它叫做ivue或者vue-ui，似乎这样的名字才更明了吧，或许好名字都早已被人抢先注册了~</p>
<p>言归正传，iView本身还是异常强大的，附iView官方文档：<a href="https://www.iviewui.com/" target="_blank" rel="noopener">https://www.iviewui.com/</a>。</p>
<h2 id="React？"><a href="#React？" class="headerlink" title="React？"></a>React？</h2><p>what？React怎么成Vue生态圈里的东西了？别激动，这不是有个问号吗？其实我只是想讲讲和React的区别罢了，瞧把你激动的。</p>
<p>相似：</p>
<p>其实都是model driven思想的严格践行者，以及通过component拆分完整整个系统的分治。</p>
<p>不同：</p>
<p>1.react基本上已经有一套遵循Flux的完整开发方案（基本上也就这一套大家默认的方式），而vue虽然有配合vuex使用，但是还有其他很多组织方式来解决，所以并不算是有固定模式，相对灵活很多，当然这个你可以看作是优势，也可以看作是不足；</p>
<p>2.react社区还是要比vue大很多；</p>
<p>3.react在view层侵入性还是要比vue大很多的；</p>
<p>4.首次渲染性能，对于大量数据来说react还是比vue有优势；</p>
<p>5.对于component的写法，react偏向于all in js，语法学习上需要下一些功夫，而vue配合vue-loader，其实在很大程度上让你不会觉得陌生–这不就是web component么。</p>
<p>是时候结束本文了，如果你对Vue依旧没有兴趣，不是你的锅，也不是Vue的锅，文章写的太烂，望海涵~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/16/2017/用户信息及设备信息采集器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/16/2017/用户信息及设备信息采集器/" itemprop="url">
                  用户信息及设备信息采集器
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-16T00:00:00+08:00">
                2017-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/06/16/2017/用户信息及设备信息采集器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/06/16/2017/用户信息及设备信息采集器/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是否还在为无法获取用户信息，无法收集设备信息而不停的码码码呢？现成的脚手架来了，地址：<a href="https://github.com/LiuLingyang/collector" target="_blank" rel="noopener">https://github.com/LiuLingyang/collector</a>，食用方式请阅读README.md。</p>
<h2 id="思路介绍"><a href="#思路介绍" class="headerlink" title="思路介绍"></a>思路介绍</h2><p>俗话说的好，最珍贵的不是代码本身，而是它的实现思路（不知道是谁说的）。总之先上图再说话。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-5d1dfea5b32e2062?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>依步骤解析：</p>
<p>1.用户访问合作站点页面；</p>
<p>2.页面打开时，会加载xxx.js文件；</p>
<p>3.xxx.js文件在客户端生成一个隐藏的iframe；</p>
<p>4.iframe与宿主机通讯，获取宿主机的基本信息，以及帆布指纹信息；</p>
<p>5.iframe将获取的信息传入自己的服务器。</p>
<p>*这里的xxx.js就是项目中的collector.bundle.js。</p>
<p>*引入iframe主要是为了解决跨应用之间的数据收集，如果你只是单应用，collector.bundle.js就已经够了（但这需要你手动去修改一些代码，兼容性做的不好）。</p>
<h2 id="信息获取流程"><a href="#信息获取流程" class="headerlink" title="信息获取流程"></a>信息获取流程</h2><p>同一用户同一设备的再次访问，我们自然不希望重新去获取这些重复的信息。第一次访问后我们会要求后台返回一个uuid给前端，而我们将其存入localStorage中。同一用户的后续访问我们只关注其变化的部分。完善的信息获取流程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-dcda99ffd55b8fa5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>*本项目只做了localStorage的判断，如果有需求，可以自行fork。</p>
<p>*帆布指纹和userAgent的解析都已经集成，无需做多余的工作。但应用信息的获取需要在客户端页面自行埋入节点，获取方式也可以多种多样。本项目是通过dom操作拿的（简单粗暴有木有）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/02/2017/浅谈 js 拖拽/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuLingyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识即性感">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/02/2017/浅谈 js 拖拽/" itemprop="url">
                  浅谈 js 拖拽
                </a>
              
            
          </h1>
        

        
        <div class="post-author"><i class="fa fa-user-o"></i>&nbsp;&nbsp;LiuLingyang</div>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-02T00:00:00+08:00">
                2017-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/其他/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/02/2017/浅谈 js 拖拽/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/01/02/2017/浅谈 js 拖拽/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文依据半年前本人的分享《浅谈js拖拽》撰写，算是一篇迟到的文章。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>虽然现在关于拖拽的组件库到处都是，HTML5也把拖放纳入了标准。但考虑到兼容问题，我们还是从最古老的方式开始讲起。</p>
<p>onmousedown：模拟开始拖拽事件。鼠标按键按下即发生onmousedown事件。获取鼠标位置，获取被拖拽元素的位置，记录两者之间的纵横坐标的差值。对document元素绑定onmousemove,onmouseup事件。 </p>
<p>为什么是对document绑定而不是对被拖动的元素绑定呢？原来是如果对被拖动元素绑定的话当鼠标拖动过快时，会导致鼠标与被拖动元素的脱离。 </p>
<p>onmousemove：模拟拖拽中事件。鼠标拖动即发生onmousemove事件。将被拖拽元素的position改成绝对位置，这个可以通过left和top改变该元素的位置，从而使得该元素随着鼠标的拖拽而移动。获取鼠标位置，将鼠标x坐标（e.clientX）减去第2步储存的横坐标差作为被拖动元素的left值，将鼠标y坐标（e.clientY）减去第2步储存的纵坐标差作为被拖动元素的top值。实现元素跟随鼠标拖动的效果。 </p>
<p>onmouseup：模拟拖拽结束事件。鼠标按键弹起即发生onmouseup事件。可以回收onmousemove和onmousedown中的事件和变量，一次拖拽至此结束。</p>
<p>（nej也提供了拖拽的一个简单案例，位于util/dragger/下，代码就不贴出来了，有兴趣的童鞋可以自行查阅，毕竟看文字实在是过于枯燥了。）</p>
<h2 id="HTML5拖放"><a href="#HTML5拖放" class="headerlink" title="HTML5拖放"></a>HTML5拖放</h2><p>有古老的方式自然有潮流的方式，如果你无需考虑兼容性问题的话，笔者强烈建议你使用HTML5提供的拖放API。如果你还未曾了解，提供你一个简单的HTML5拖放实例<a href="http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop" target="_blank" rel="noopener">http://www.w3school.com.cn/tiy/t.asp?f=html5_draganddrop</a>。</p>
<p>让我们一起来看看HTML5拖放相关的一些知识点。</p>
<p><strong>7个事件：</strong></p>
<p>dragstart：当用户开始拖动对象时触发。</p>
<p>dragenter： 当鼠标第一次经过目标元素，且有拖动发生时触发。此事件的监听者应指明在这个位置上是否允许drop，或者监听者不执行任何操作，那么drop默认是不允许的。</p>
<p>dragover：当鼠标经过一个元素时，且有拖动发生时触发 。</p>
<p>dragleave：当鼠标离开一个元素，且有拖动在发生时触发。</p>
<p>drag： 当对象被拖动，每次移动鼠标时触发。</p>
<p>drop：在drag操作的最后发生drop时，在元素上触发此事件。监听者应该负责检索拖动的数据，并插入drop的位置。</p>
<p>dragend： 在拖动对象时放开鼠标按键时触发。</p>
<p><strong>draggable属性：</strong></p>
<p>如果网页元素的draggable元素为true，这个元素就是可以拖动的。</p>
<pre><div draggable="true">Draggable Div</div></pre>

<p><strong>dataTransfer对象：</strong></p>
<p>拖动过程中，回调函数接受的事件参数，有一个dataTransfer属性。它指向一个对象，包含了与拖动相关的各种信息。</p>
<p>dataTransfer对象的属性:</p>
<ul>
<li>dropEffect：拖放的操作类型，决定了浏览器如何显示鼠标形状，可能的值为copy、move、link和none。</li>
<li>effectAllowed：指定所允许的操作，可能的值为copy、move、link、copyLink、copyMove、linkMove、all、none和uninitialized（默认值，等同于all，即允许一切操作）。</li>
<li>files：包含一个FileList对象，表示拖放所涉及的文件，主要用于处理从文件系统拖入浏览器的文件。</li>
<li>types：储存在DataTransfer对象的数据的类型。</li>
<li>dataTransfer对象的方法：</li>
<li>setData(format, data)：在dataTransfer对象上储存数据。第一个参数format用来指定储存的数据类型，比如text、url、text/html等。</li>
<li>getData(format)：从dataTransfer对象取出数据。</li>
<li>clearData(format)：清除dataTransfer对象所储存的数据。如果指定了format参数，则只清除该格式的数据，否则清除所有数据。</li>
<li>setDragImage(imgElement, x, y)：指定拖动过程中显示的图像。默认情况下，许多浏览器显示一个被拖动元素的半透明版本。参数imgElement必须是一个图像元素，而不是指向图像的路径，参数x和y表示图像相对于鼠标的位置。</li>
</ul>
<p>dataTransfer对象，允许在其上存储数据，这使得在被拖动元素与目标元素之间传送信息成为可能。</p>
<p><strong>e.preventDefault():</strong></p>
<p>ondragover有一个默认行为，那就是当ondragover触发时，ondrop会失效！</p>
<p>如何阻止？</p>
<pre data-type="javascript">ondragover = function(e){</pre>

<pre data-type="javascript">    e.preventDefault();</pre>

<pre data-type="javascript">    ....</pre>

<pre data-type="javascript">}</pre>

<p>附一张整理好的图片供大家理解：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-e3f1caa17193f21c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>扯了这么多，最后再举个栗子来结束本文。先上图片…</p>
<p><img src="http://upload-images.jianshu.io/upload_images/13276697-f9a4a35e17da8815?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这是笔者在网易有数项目中的一个需求，实现文件拖拽上传。</p>
<p>实现步骤：</p>
<p>  1.监听事件</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/13276697-34c74f5bf800a8f1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>  其中dragenter和dragleave只是处理了外框高亮的效果，如上面图片所示。</p>
<p>  需要注意的是一定要将dragover的默认事件取消掉，不然无法触发drop事件。可以用preventDefault()，也可以用nej的_v._$stop(_event)。如需拖拽页面里的元素，需要给其添加属性draggable=”true”。这些上文已经有所提及。</p>
<p>  2.处理drop事件</p>
<p>  在drop事件回调函数中通过_event.dataTransfer.files获取拖拽文件列表。dataTransfer对象真是个好东西。</p>
<p>  3.发送文件数据</p>
<p>  使用FormData模拟表单数据AJAX提交文件流。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/13276697-f1a888eccb80074b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>  至此，HTML5的文件拖拽上传就实现了，是不是很easy？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="LiuLingyang">
          <p class="site-author-name" itemprop="name">LiuLingyang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuLingyang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 95658, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/95658/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	












  





  

  

  

  

</body>
</html>
